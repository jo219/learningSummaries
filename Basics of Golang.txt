Main structure
package main

import (
  "<whatever>"
)

func main() {
  <code>
}

Basic use of fmt package
fmt.Printf for literal string print like Printf("Apple count: %v", apl)
fmt.Print for direct variable print, use Println for \n end embedded
n.b. imported function capitalized, local doesn't

Function defining
func addAndSubstract1 (x, y int) (int, int) {
  return x+y, x-y
}
func addAndSubstract2 (x, y int) (a, b int) {
  a = x+y
  b = x-y
  return  //naked return
}

Variable defining
Explicit var a, b, c bool // = true, true, false
Implicit a, b, c := true, true, false
Casting T(v) like float64(a)
Constant const Pi = 3.14 or const Name = "조수아" which can't use :=

Types
bool string int(8/16/32/64) uint(+ptr)
byte(=uint8) rune(=uint32) float(32/64) complex(64/128)

For, If, Switch, Defer
sum := 0
for (i := 0;) i<10(; i++) {  //like while()
  // for {} == while(1) {}
  sum += i
}
if (i := 20;) sum < i {
  return i  // disappear after if-block
} (else { })
switch (i := season();) i {  // no condition == if true
  case "a":
   fmt.Println(i)
  default:
   fmt.Printf("no data\n")
}
defer fmt.Printf("The end") // evaluated immediately, but executed right before return, can be stacked

Pointer, Struct
Pointer just talk about * and &, and *(datatype) 
type Vertex struct {
 X, Y int
}
func main() {
 v := Vertex{1, 2}  // v is pointer, *v prints the struct values
 v.X = 4  // this one is normal var
 fmt.Println(v.X)
}

Array and Slice
var a [3]int (= [3]int{1,2,3})  // simply a := [3]int{1,2,3}
var s1 []int = a[1:3]  // len: def-def, cap: def-src
s2 := make([]int, <len>, <cap>)
s2 = append(s2, 5, 3) // len++, cap++ (have default format if overloaded with new appended data)
for i, v := range s2 {}  // i:index v:value

Map
var a map[<key-type>]<value-type>


Function as parameter (value)
Function as return value (closure)

Method (Function embedded to type/struct)
Interface (a type with defined methods for several child type/struct)

Reader (?)

Goroutine (channel [buffer-range, close], select-case)
sync.Mutex for Lock() and Unlock()
